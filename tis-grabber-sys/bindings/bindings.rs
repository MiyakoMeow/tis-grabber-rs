/* automatically generated by rust-bindgen 0.70.1 */

pub const NOHWNDDEFINED: i8 = 1;
pub const IC_SUCCESS: i8 = 1;
pub const IC_ERROR: i8 = 0;
pub const IC_NO_HANDLE: i8 = -1;
pub const IC_NO_DEVICE: i8 = -2;
pub const IC_NOT_AVAILABLE: i8 = -3;
pub const IC_NO_PROPERTYSET: i8 = -3;
pub const IC_DEFAULT_WINDOW_SIZE_SET: i8 = -3;
pub const IC_NOT_IN_LIVEMODE: i8 = -3;
pub const IC_PROPERTY_ITEM_NOT_AVAILABLE: i8 = -4;
pub const IC_PROPERTY_ELEMENT_NOT_AVAILABLE: i8 = -5;
pub const IC_PROPERTY_ELEMENT_WRONG_INTERFACE: i8 = -6;
pub const IC_INDEX_OUT_OF_RANGE: i8 = -7;
pub const IC_WRONG_XML_FORMAT: i8 = -1;
pub const IC_WRONG_INCOMPATIBLE_XML: i8 = -3;
pub const IC_NOT_ALL_PROPERTIES_RESTORED: i8 = -4;
pub const IC_DEVICE_NOT_FOUND: i8 = -5;
pub const IC_FILE_NOT_FOUND: i8 = 35;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMG_FILETYPE {
    FILETYPE_BMP = 0,
    FILETYPE_JPEG = 1,
    FILETYPE_MEGA = 65536,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum COLORFORMAT {
    Y800 = 0,
    RGB24 = 1,
    RGB32 = 2,
    UYVY = 3,
    Y16 = 4,
    NONE = 5,
    COLORFORMAT_MEGA = 65536,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VIDEO_PROPERTY {
    PROP_VID_BRIGHTNESS = 0,
    PROP_VID_CONTRAST = 1,
    PROP_VID_HUE = 2,
    PROP_VID_SATURATION = 3,
    PROP_VID_SHARPNESS = 4,
    PROP_VID_GAMMA = 5,
    PROP_VID_COLORENABLE = 6,
    PROP_VID_WHITEBALANCE = 7,
    PROP_VID_BLACKLIGHTCOMPENSATION = 8,
    PROP_VID_GAIN = 9,
    PROP_VID_MEGA = 65536,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CAMERA_PROPERTY {
    PROP_CAM_PAN = 0,
    PROP_CAM_TILT = 1,
    PROP_CAM_ROLL = 2,
    PROP_CAM_ZOOM = 3,
    PROP_CAM_EXPOSURE = 4,
    PROP_CAM_IRIS = 5,
    PROP_CAM_FOCUS = 6,
    PROP_CAM_MEGA = 65536,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FRAMEFILTER_PARAM_TYPE {
    eParamLong = 0,
    eParamBoolean = 1,
    eParamFloat = 2,
    eParamString = 3,
    eParamData = 4,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PROPERTY_INTERFACE_TYPE {
    ePropertyRange = 0,
    ePropertyAbsoluteValue = 1,
    ePropertySwitch = 2,
    ePropertyButton = 3,
    ePropertyMapStrings = 4,
    ePropertyUnknown = 5,
}
#[doc = "\n*! This is the handle of an grabber object. Please use the HGRABBER type to access\nthis object.\n*/"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct HGRABBER_t__ {
    #[doc = "<Internal structure of the grabber object handle."]
    pub unused: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HGRABBER_t__"][::core::mem::size_of::<HGRABBER_t__>() - 4usize];
    ["Alignment of HGRABBER_t__"][::core::mem::align_of::<HGRABBER_t__>() - 4usize];
    ["Offset of field: HGRABBER_t__::unused"]
        [::core::mem::offset_of!(HGRABBER_t__, unused) - 0usize];
};
#[doc = "\n*! This is the handle of an grabber object. Please use the HGRABBER type to access\nthis object.\n*/"]
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct HGRABBER_t(pub HGRABBER_t__);
impl ::core::ops::Deref for HGRABBER_t {
    type Target = HGRABBER_t__;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::core::ops::DerefMut for HGRABBER_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct FILTERPARAMETER_t__ {
    pub Name: [::core::ffi::c_char; 30usize],
    pub Type: FRAMEFILTER_PARAM_TYPE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FILTERPARAMETER_t__"][::core::mem::size_of::<FILTERPARAMETER_t__>() - 36usize];
    ["Alignment of FILTERPARAMETER_t__"][::core::mem::align_of::<FILTERPARAMETER_t__>() - 4usize];
    ["Offset of field: FILTERPARAMETER_t__::Name"]
        [::core::mem::offset_of!(FILTERPARAMETER_t__, Name) - 0usize];
    ["Offset of field: FILTERPARAMETER_t__::Type"]
        [::core::mem::offset_of!(FILTERPARAMETER_t__, Type) - 32usize];
};
impl Default for FILTERPARAMETER_t__ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct FILTERPARAMETER_t(pub FILTERPARAMETER_t__);
impl ::core::ops::Deref for FILTERPARAMETER_t {
    type Target = FILTERPARAMETER_t__;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::core::ops::DerefMut for FILTERPARAMETER_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct HFRAMEFILTER_t__ {
    pub pFilter: *mut ::core::ffi::c_void,
    pub bHasDialog: ::core::ffi::c_int,
    pub ParameterCount: ::core::ffi::c_int,
    pub Parameters: *mut FILTERPARAMETER_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HFRAMEFILTER_t__"][::core::mem::size_of::<HFRAMEFILTER_t__>() - 24usize];
    ["Alignment of HFRAMEFILTER_t__"][::core::mem::align_of::<HFRAMEFILTER_t__>() - 8usize];
    ["Offset of field: HFRAMEFILTER_t__::pFilter"]
        [::core::mem::offset_of!(HFRAMEFILTER_t__, pFilter) - 0usize];
    ["Offset of field: HFRAMEFILTER_t__::bHasDialog"]
        [::core::mem::offset_of!(HFRAMEFILTER_t__, bHasDialog) - 8usize];
    ["Offset of field: HFRAMEFILTER_t__::ParameterCount"]
        [::core::mem::offset_of!(HFRAMEFILTER_t__, ParameterCount) - 12usize];
    ["Offset of field: HFRAMEFILTER_t__::Parameters"]
        [::core::mem::offset_of!(HFRAMEFILTER_t__, Parameters) - 16usize];
};
impl Default for HFRAMEFILTER_t__ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct HFRAMEFILTER_t(pub HFRAMEFILTER_t__);
impl ::core::ops::Deref for HFRAMEFILTER_t {
    type Target = HFRAMEFILTER_t__;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::core::ops::DerefMut for HFRAMEFILTER_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
extern "C" {
    #[doc = "\n*! Initialize the ICImagingControl class library. This function must be called\nonly once before any other functions of this library are called.\n@param szLicenseKey IC Imaging Control license key or NULL if only a trial version is available.\n@retval IC_SUCCESS on success.\n@retval IC_ERROR on wrong license key or other errors.\n@sa IC_CloseLibrary\n\n*/"]
    pub fn IC_InitLibrary(szLicenseKey: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Creates a new grabber handle and returns it. A new created grabber should be\nrelease with a call to IC_ReleaseGrabber if it is no longer needed.\n@retval IC_SUCCESS on success.\n@retval IC_ERROR if an error occurred.\n@sa IC_ReleaseGrabber\n*/"]
    pub fn IC_CreateGrabber() -> *mut HGRABBER_t;
}
extern "C" {
    #[doc = "\n*! Release the grabber object. Must be called, if the calling application\ndoes no longer need the grabber.\n@param hGrabber The handle to grabber to be released.\n@sa IC_CreateGrabber\n*/"]
    pub fn IC_ReleaseGrabber(hGrabber: *mut *mut HGRABBER_t);
}
extern "C" {
    pub fn IC_CloseLibrary();
}
extern "C" {
    #[doc = "\n*! Open a video capture device. The hGrabber handle must have been created previously by\na call to IC_CreateGrabber(). Once a hGrabber handle has been created it can be\nrecycled to open different video capture devices in sequence.\n@param hGrabber The handle to grabber object, that has been created by a call to IC_CreateGrabber\n@param szDeviceName Friendly name of the video capture device e.g. \"DFK 21F04\".\n@retval IC_SUCCESS on success.\n@retval IC_ERROR on errors.\n@sa IC_CloseVideoCaptureDevice\n\n@code\n#include \"tisgrabber.h\"\nvoid main()\n{\nHGRABBER hGrabber;\nif( IC_InitLibrary(0) == IC_SUCCESS )\n{\nhGrabber = IC_CreateGrabber();\nif( hGrabber )\n{\nif( IC_OpenVideoCaptureDevice(hGrabber,\"DFK 21F04\") == IC_SUCCESS )\n{\n\n .. do something with the video capture device.\n\n Now clean up.\nIC_CloseVideoCaptureDevice( hGrabber );\nIC_ReleaseGrabber( hGrabber );\n}\nIC_CloseLibrary();\n}\n}\n@endcode\n*/"]
    pub fn IC_OpenVideoCaptureDevice(
        hGrabber: *mut HGRABBER_t,
        szDeviceName: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Close the current video capture device. The HGRABBER object will not be deleted.\nIt can be used again for opening another video capture device.\n@param hGrabber The handle to the grabber object.\n*/"]
    pub fn IC_CloseVideoCaptureDevice(hGrabber: *mut HGRABBER_t);
}
extern "C" {
    #[doc = "\n*! Retrieve the name of the current video capture device. If the device is\ninvalid, NULL is returned.\n@param hGrabber The handle to the grabber object.\n@retval char* The name of the video capture device\n@retval NULL  If no video capture device is currently opened.\n*/"]
    pub fn IC_GetDeviceName(hGrabber: *mut HGRABBER_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn IC_GetVideoFormatWidth(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_GetVideoFormatHeight(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Set the sink type. A sink type must be set before images can be snapped.\nThe sink type basically describes the format of the buffer where the snapped\nimages are stored.\n\nPossible values for format are:\n@li Y800\n@li RGB24\n@li RGB32\n@li UYVY\n\nThe sink type may differ from the currently set video format.\n\n@param hGrabber The handle to the grabber object.\n@param format The desired color format. Possible values for format are:\n@li Y800\n@li RGB24\n@li RGB32\n@li UYVY\n@retval IC_SUCCESS on success\n@retval IC_ERROR if something went wrong.\n\n@note Please note that UYVY can only be used in conjunction with a UYVY video format.\n\n\n*/"]
    pub fn IC_SetFormat(hGrabber: *mut HGRABBER_t, format: COLORFORMAT) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Retrieves the format of the sink type currently set (See IC_SetFormat()\nfor possible formats). If no sink type is set\nor an error occurred, NONE is returned.\nThe function returns a valid value only after IC_PreprareLive() or IC_StartLive()\nwas called. Before these calls, NONE is returned.\n@param hGrabber The handle to the grabber object.\n@return The current sink color format.\n*/"]
    pub fn IC_GetFormat(hGrabber: *mut HGRABBER_t) -> COLORFORMAT;
}
extern "C" {
    #[doc = "\n*! Set a video format for the current video capture device. The video format\nmust be supported by the current video capture device.\n@param hGrabber The handle to the grabber object.\n@param szFormat A string that contains the desired video format.\n@retval IC_SUCCESS on success\n@retval IC_ERROR if something went wrong.\n\n@code\n#include \"tisgrabber.h\"\nvoid main()\n{\nHGRABBER hGrabber;\nif( IC_InitLibrary(0) == IC_SUCCESS )\n{\nhGrabber = IC_CreateGrabber();\nif( hGrabber )\n{\nif( IC_OpenVideoCaptureDevice(hGrabber,\"DFK 21F04\") == IC_SUCCESS )\n{\nif( IC_SetVideoFormat(hGrabber,\"UYVY (640x480)\" == IC_SUCCESS )\n{\n .. do something with the video capture device.\n}\n Now clean up.\nIC_CloseVideoCaptureDevice( hGrabber );\nIC_ReleaseGrabber( hGrabber );\n}\nIC_CloseLibrary();\n}\n}\n}\n@endcode\n*/"]
    pub fn IC_SetVideoFormat(
        hGrabber: *mut HGRABBER_t,
        szFormat: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Set a video norm for the current video capture device.\n@note  The current video capture device must support video norms.\n@param hGrabber The handle to the grabber object.\n@param szNorm A string that contains the desired video format.\n@retval IC_SUCCESS on success\n@retval IC_ERROR if something went wrong.\n*/"]
    pub fn IC_SetVideoNorm(
        hGrabber: *mut HGRABBER_t,
        szNorm: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Set a input channel for the current video capture device.\n@note  The current video capture device must support input channels..\n@param hGrabber The handle to the grabber object.\n@param szChannel A string that contains the desired video format.\n@retval IC_SUCCESS on success\n@retval IC_ERROR if something went wrong.\n*/"]
    pub fn IC_SetInputChannel(
        hGrabber: *mut HGRABBER_t,
        szChannel: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Start the live video.\n@param hGrabber The handle to the grabber object.\n@param iShow The parameter indicates:   @li 1 : Show the video\t@li 0 : Do not show the video, but deliver frames. (For callbacks etc.)\n@retval IC_SUCCESS on success\n@retval IC_ERROR if something went wrong.\n@sa IC_StopLive\n*/"]
    pub fn IC_StartLive(hGrabber: *mut HGRABBER_t, iShow: ::core::ffi::c_int)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_PrepareLive(
        hGrabber: *mut HGRABBER_t,
        iShow: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_SuspendLive(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Check, whether the passed grabber already provides are live video\n@param hGrabber The handle to the grabber object.\n@retval 1 : Livevideo is running, 0 : Livevideo is not running.\n@retval IC_NO_HANDLE   hGrabber is not a valid handle. GetGrabber was not called.\n@retval IC_NO_DEVICE   No device opened. Open a device, before this function can be used.\n\n*/"]
    pub fn IC_IsLive(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Stop the live video.\n@param hGrabber The handle to the grabber object.\n@sa IC_StartLive\n*/"]
    pub fn IC_StopLive(hGrabber: *mut HGRABBER_t);
}
extern "C" {
    #[doc = "\n*! Check, whether a property is supported by the current video capture device.\n@param hGrabber The handle to the grabber object.\n@sa eProperty The cammera property to be checked\n@retval IC_SUCCESS\tThe property is supported.\n@retval IC_ERROR\tThe property is not supported.\n@retval IC_NO_HANDLE   hGrabber is not a valid handle. GetGrabber was not called.\n@retval IC_NO_DEVICE   No device opened. Open a device, before this function can be used.\n\n*/"]
    pub fn IC_IsCameraPropertyAvailable(
        hGrabber: *mut HGRABBER_t,
        eProperty: CAMERA_PROPERTY,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Set a camera property like exposure, zoom.\n\n@param hGrabber The handle to the grabber object.\n@param eProperty The property to be set. It can have following values:\n@li PROP_CAM_PAN\n@li PROP_CAM_TILT,\n@li PROP_CAM_ROLL,\n@li PROP_CAM_ZOOM,\n@li PROP_CAM_EXPOSURE,\n@li PROP_CAM_IRIS,\n@li PROP_CAM_FOCUS\n@param lValue The value the property is to be set to.\n@retval IC_SUCCESS on success\n@retval IC_ERROR if something went wrong.\n\n@note  lValue should be in the range of the specified property.\nIf the value could not be set (out of range, auto is currently enabled), the\nfunction returns 0. On success, the functions returns 1.\n*/"]
    pub fn IC_SetCameraProperty(
        hGrabber: *mut HGRABBER_t,
        eProperty: CAMERA_PROPERTY,
        lValue: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_CameraPropertyGetRange(
        hGrabber: *mut HGRABBER_t,
        eProperty: CAMERA_PROPERTY,
        lMin: *mut ::core::ffi::c_long,
        lMax: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_GetCameraProperty(
        hGrabber: *mut HGRABBER_t,
        eProperty: CAMERA_PROPERTY,
        lValue: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Enable or disable automatic for a camera property.\n@param hGrabber The handle to the grabber object.\n@param iProperty  The property to be set. It can have following values:\n@li PROP_CAM_PAN\n@li PROP_CAM_TILT,\n@li PROP_CAM_ROLL,\n@li PROP_CAM_ZOOM,\n@li PROP_CAM_EXPOSURE,\n@li PROP_CAM_IRIS,\n@li PROP_CAM_FOCUS\n@param iOnOFF Enables or disables the automation. Possible values ar\n@li 1 : Enable automatic\n@li 0 : Disable Automatic\n@retval IC_SUCCESS on success\n@retval IC_ERROR if something went wrong.\n\n@note If the property is not supported by the current video capture device or\nautomation of the property is not available with the current video capture\ndevice, the function returns 0. On success, the function returns 1.\n*/"]
    pub fn IC_EnableAutoCameraProperty(
        hGrabber: *mut HGRABBER_t,
        iProperty: ::core::ffi::c_int,
        iOnOff: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_IsCameraPropertyAutoAvailable(
        hGrabber: *mut HGRABBER_t,
        iProperty: CAMERA_PROPERTY,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_GetAutoCameraProperty(
        hGrabber: *mut HGRABBER_t,
        iProperty: ::core::ffi::c_int,
        iOnOff: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_IsVideoPropertyAvailable(
        hGrabber: *mut HGRABBER_t,
        eProperty: VIDEO_PROPERTY,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_VideoPropertyGetRange(
        hGrabber: *mut HGRABBER_t,
        eProperty: VIDEO_PROPERTY,
        lMin: *mut ::core::ffi::c_long,
        lMax: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_GetVideoProperty(
        hGrabber: *mut HGRABBER_t,
        eProperty: VIDEO_PROPERTY,
        lValue: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_IsVideoPropertyAutoAvailable(
        hGrabber: *mut HGRABBER_t,
        eProperty: VIDEO_PROPERTY,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_GetAutoVideoProperty(
        hGrabber: *mut HGRABBER_t,
        iProperty: ::core::ffi::c_int,
        iOnOff: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Set a video property like brightness, contrast.\n\n@param hGrabber The handle to the grabber object.\n@param eProperty The property to be set. It can have following values:\n@li PROP_VID_BRIGHTNESS ,\n@li PROP_VID_CONTRAST,\n@li PROP_VID_HUE,\n@li PROP_VID_SATURATION,\n@li PROP_VID_SHARPNESS,\n@li PROP_VID_GAMMA,\n@li PROP_VID_COLORENABLE,\n@li PROP_VID_WHITEBALANCE,\n@li PROP_VID_BLACKLIGHTCOMPENSATION,\n@li PROP_VID_GAIN\n@param lValue The value the property is to be set to.\n@retval IC_SUCCESS on success\n@retval IC_ERROR if something went wrong.\n\n@note lValue should be in the range of the specified property.\nIf the value could not be set (out of range, auto is currently enabled), the\nfunction returns 0. On success, the functions returns 1.\n*/"]
    pub fn IC_SetVideoProperty(
        hGrabber: *mut HGRABBER_t,
        eProperty: VIDEO_PROPERTY,
        lValue: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Enable or disable automatic for a video propertery.\n@param hGrabber The handle to the grabber object.\n@param iProperty The property to be set. It can have following values:\n@li PROP_VID_BRIGHTNESS,\n@li PROP_VID_CONTRAST,\n@li PROP_VID_HUE,\n@li PROP_VID_SATURATION,\n@li PROP_VID_SHARPNESS,\n@li PROP_VID_GAMMA,\n@li PROP_VID_COLORENABLE,\n@li PROP_VID_WHITEBALANCE,\n@li PROP_VID_BLACKLIGHTCOMPENSATION,\n@li PROP_VID_GAIN\n@param iOnOFF Enables or disables the automation. Possible values ar\n@li 1 : Enable automatic\n@li 0 : Disable Automatic\n@retval IC_SUCCESS on success\n@retval IC_ERROR if something went wrong.\n\n@note If the property is not supported by the current video capture device or\nautomation of the property is not available with the current video capture\ndevice, the function reurns 0. On success, the function returns 1.\n*/"]
    pub fn IC_EnableAutoVideoProperty(
        hGrabber: *mut HGRABBER_t,
        iProperty: ::core::ffi::c_int,
        iOnOff: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Retrieve the properties of the current video format and sink type\n@param hGrabber The handle to the grabber object.\n@param *lWidth  This recieves the width of the image buffer.\n@param *lHeight  This recieves the height of the image buffer.\n@param *iBitsPerPixel  This recieves the count of bits per pixel.\n@param *format  This recieves the current color format.\n@retval IC_SUCCESS on success\n@retval IC_ERROR if something went wrong.\n*/"]
    pub fn IC_GetImageDescription(
        hGrabber: *mut HGRABBER_t,
        lWidth: *mut ::core::ffi::c_long,
        lHeight: *mut ::core::ffi::c_long,
        iBitsPerPixel: *mut ::core::ffi::c_int,
        format: *mut COLORFORMAT,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Snaps an image. The video capture device must be set to live mode and a\nsink type has to be set before this call. The format of the snapped images depend on\nthe selected sink type.\n\n@param hGrabber The handle to the grabber object.\n@param iTimeOutMillisek The Timeout time is passed in milli seconds. A value of -1 indicates, that\nno time out is set.\n\n\n@retval IC_SUCCESS if an image has been snapped\n@retval IC_ERROR if something went wrong.\n@retval IC_NOT_IN_LIVEMODE if the live video has not been started.\n\n@sa IC_StartLive\n@sa IC_SetFormat\n\n*/"]
    pub fn IC_SnapImage(
        hGrabber: *mut HGRABBER_t,
        iTimeOutMillisek: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Save the contents of the last snapped image by IC_SnapImage into a file.\n@param hGrabber The handle to the grabber object.\n@param szFileName String containing the file name to be saved to.\n@param ft File type if the image, It have be\n@li FILETYPE_BMP for bitmap files\n@li FILETYPE_JPEG for JPEG file.\n@param quality If the JPEG format is used, the image quality must be specified in a range from 0 to 100.\n@retval IC_SUCCESS if an image has been snapped\n@retval IC_ERROR if something went wrong.\n\n@remarks\nThe format of the saved images depend on the sink type. If the sink type\nis set to Y800, the saved image will be an 8 Bit grayscale image. In any\nother case the saved image will be a 24 Bit RGB image.\n\n@note IC Imaging Control 1.41 only supports FILETYPE_BMP.\n@sa IC_SnapImage\n@sa IC_SetFormat\n*/"]
    pub fn IC_SaveImage(
        hGrabber: *mut HGRABBER_t,
        szFileName: *mut ::core::ffi::c_char,
        ft: IMG_FILETYPE,
        quality: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Retrieve a byte pointer to the image data (pixel data) of the last snapped\nimage (see SnapImage()). If the function fails, the return value is NULL\notherwise the value is a pointer to the first byte in the lowest image line\n(the image is saved bottom up!).\n@param hGrabber The handle to the grabber object.\n@retval Nonnull Pointer to the image data\n@retval NULL Indicates that an error occurred.\n@sa IC_SnapImage\n@sa IC_SetFormat\n*/"]
    pub fn IC_GetImagePtr(hGrabber: *mut HGRABBER_t) -> *mut ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = "\n*! Assign an Window handle to display the video in.\n@param hGrabber The handle to the grabber object.\n@param hWnd The handle of the window where to display the live video in.\n@retval IC_SUCCESS if an image has been snapped\n@retval IC_ERROR if something went wrong.\n*/"]
    pub fn IC_SetHWnd(hGrabber: *mut HGRABBER_t, hWnd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Return the serialnumber of the current device. Memory for the serialnumber\nmust has been allocated by the application:\n\n@code\nchar szSerial[20];\nGetSerialNumber( hGrabber, szSerial );\n@endcode\n\nThis function decodes the The Imaging Source serialnumbers.\n@param hGrabber The handle to the grabber object.\n@param szSerial char array that recieves the serial number.\n@retval IC_SUCCESS The serial number could be retrieved.\n@retval IC_IC_NOT_AVAILABLE The video capture device does not provide a serial number.\n@retval IC_NO_DEVICE No video capture device opened-\n@retval IC_NO_HANDLE hGrabber is NULL.\n*/"]
    pub fn IC_GetSerialNumber(
        hGrabber: *mut HGRABBER_t,
        szSerial: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Count all connected video capture devices. If the Parameter szDeviceList\nis NULL, only the number of devices is queried. The Parameter szDeviceList\nmust be a two dimensional array of char. The iSize parameter specifies the\nlength of the strings, that are used in the array.\n\n@param szDeviceList A two dimensional char array that recieves the list. Or NULL if only the count of devices is to be returned.\n@param iSize Not used.\n@retval >= 0 Success, count of found devices\n@retval <0 An error occurred.\n\nSimple sample to list the video capture devices:\n@code\nchar szDeviceList[20][40];\nint iDeviceCount;\n\niDeviceCount = IC_ListDevices( (char*)szDeviceList,40 );\nfor( i = 0; i < iDeviceCount; i++ )\n{\nprintf(\"%2d. %s\\n\",i+1,szDeviceList[i]);\n}\n@endcode\n*/"]
    pub fn IC_ListDevices(
        szDeviceList: *mut ::core::ffi::c_char,
        iSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Simpler approach of enumerating devices. No 2D char array needed\n\n@code\nchar szDeviceName[40]; // Use max 39 chars for a device name\nint iDeviceCount;\n\niDeviceCount = IC_GetDeviceCount(); // Query number of connected devices\nfor( i = 0; i < iDeviceCount; i++ )\n{\nIC_ListDevicesbyIndex(szDeviceName,39, i);\nprintf(\"%2d. %s\\n\",i+1,szDeviceName);\n}\n@endcode\n@param szDeviceName Char memory, that receives the device name\n@param iSize Size of the char memory. If names are longer, they will be truncated.\n@param DeviceIndex Index of the device to be query. Must be between 0 and IC_GetDeviceCount.\n\n@retval >= 0 Success, count of found devices\n@retval <0 An error occurred.\n\n*/"]
    pub fn IC_ListDevicesbyIndex(
        szDeviceName: *mut ::core::ffi::c_char,
        iSize: ::core::ffi::c_int,
        DeviceIndex: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Count all available video formats. If the Parameter szFormatList\nis NULL, only the number of formats is queried. The Parameter szFormatList\nmust be a two dimensional array of char. The iSize parameter specifies the\nlength of the strings, that are used in the array to store the format names.\n\n@param hGrabber The handle to the grabber object.\n@param szFormatList A two dimensional char array that recieves the list. Or NULL if only the count of formats is to be returned.\n\n@retval >= 0 Success, count of found video formats\n@retval <0 An error occurred.\n\nSimple sample to list the video capture devices:\n@code\nchar szFormatList[80][40];\nint iFormatCount;\nHGRABBER hGrabber;\nhGrabber = IC_CreateGrabber();\nIC_OpenVideoCaptureDevice(hGrabber, \"DFK 21F04\" );\niFormatCount = IC_ListDevices(hGrabber, (char*)szFormatList,40 );\nfor( i = 0; i < min( iFormatCount, 80); i++ )\n{\nprintf(\"%2d. %s\\n\",i+1,szFormatList[i]);\n}\nIC_ReleaseGrabber( hGrabber );\n@endcode\n*/"]
    pub fn IC_ListVideoFormats(
        hGrabber: *mut HGRABBER_t,
        szFormatList: *mut ::core::ffi::c_char,
        iSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Simpler approach of enumerating video formats. No 2D char array needed.\n\n@param hGrabber The handle to the grabber object.\n@param szFormatName char memory, that will receive the name of the video format. Should be big enough.\n@param iSize Size in byte of szFormatName\n@iIndex Index of the video format to query.\n\n@code\nchar szVideoFormatName[40]; // Use max 39 chars for a video format name\nint FormatCount;\nHGRABBER hGrabber;\nhGrabber = IC_CreateGrabber();\nIC_OpenVideoCaptureDevice(hGrabber, \"DFK 21AU04\" );\nFormatCount = IC_GetVideoFormatCount(hGrabber); // Query number of connected devices\nfor( i = 0; i < FormatCount; i++ )\n{\nIC_ListVideoFormatbyIndex(szVideoFormatName,39, i);\nprintf(\"%2d. %s\\n\",i+1,szVideoFormatName);\n}\n@endcode\n@param szDeviceName Char memory, that receives the device name\n@param iSize Size of the char memory. If names are longer, they will be truncated.\n@param DeviceIndex Index of the device to be query. Must be between 0 and IC_GetDeviceCount.\n\n@retval IC_SUCCESS Success,\n@retval IC_NO_DEVICE No video capture device selected.\n@retval IC_NO_HANDLE No handle to the grabber object.\n\n*/"]
    pub fn IC_ListVideoFormatbyIndex(
        hGrabber: *mut HGRABBER_t,
        szFormatName: *mut ::core::ffi::c_char,
        iSize: ::core::ffi::c_int,
        iIndex: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Get the number of the currently available devices. This function creates an\ninternal array of all connected video capture devices. With each call to this\nfunction, this array is rebuild. The name and the unique name can be retrieved\nfrom the internal array using the functions IC_GetDevice() and IC_GetUniqueNamefromList.\nThey are usefull for retrieving device names for opening devices.\n\n@retval >= 0 Success, count of found devices.\n@retval IC_NO_HANDLE Internal Error.\n\n@sa IC_GetDevice\n@sa IC_GetUniqueNamefromList\n*/"]
    pub fn IC_GetDeviceCount() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Get a string representation of a device specified by iIndex. iIndex\nmust be between 0 and IC_GetDeviceCount(). IC_GetDeviceCount() must\nhave been called before this function, otherwise it will always fail.\n\n@param iIndex The number of the device whose name is to be returned. It must be\nin the range from 0 to IC_GetDeviceCount(),\n@return Returns the string representation of the device on success, NULL\notherwise.\n\n@sa IC_GetDeviceCount\n@sa IC_GetUniqueNamefromList\n*/"]
    pub fn IC_GetDevice(iIndex: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = "\n*! Get unique device name of a device specified by iIndex. The unique device name\nconsist from the device name and its serial number. It allows to differ between\nmore then one device of the same type connected to the computer. The unique device name\nis passed to the function IC_OpenDevByUniqueName\n\n@param iIndex The number of the device whose name is to be returned. It must be\nin the range from 0 to IC_GetDeviceCount(),\n@return Returns the string representation of the device on success, NULL\notherwise.\n\n@sa IC_GetDeviceCount\n@sa IC_GetUniqueNamefromList\n@sa IC_OpenDevByUniqueName\n*/"]
    pub fn IC_GetUniqueNamefromList(iIndex: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = "\n*! Get the number of the available input channels for the current device.\nA video\tcapture device must have been opened before this call.\n\n@param hGrabber The handle to the grabber object.\n\n@retval >= 0 Success\n@retval IC_NO_DEVICE No video capture device selected.\n@retval IC_NO_HANDLE No handle to the grabber object.\n\n@sa IC_GetInputChannel\n*/"]
    pub fn IC_GetInputChannelCount(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Get a string representation of the input channel specified by iIndex.\niIndex must be between 0 and IC_GetInputChannelCount().\nIC_GetInputChannelCount() must have been called before this function,\notherwise it will always fail.\n@param hGrabber The handle to the grabber object.\n@param iIndex Number of the input channel to be used..\n\n@retval Nonnull The name of the specified input channel\n@retval NULL An error occured.\n@sa IC_GetInputChannelCount\n*/"]
    pub fn IC_GetInputChannel(
        hGrabber: *mut HGRABBER_t,
        iIndex: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = "\n*! Get the number of the available video norms for the current device.\nA video capture device must have been opened before this call.\n\n@param hGrabber The handle to the grabber object.\n\n@retval >= 0 Success\n@retval IC_NO_DEVICE No video capture device selected.\n@retval IC_NO_HANDLE No handle to the grabber object.\n\n@sa IC_GetVideoNorm\n*/"]
    pub fn IC_GetVideoNormCount(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Get a string representation of the video norm specified by iIndex.\niIndex must be between 0 and IC_GetVideoNormCount().\nIC_GetVideoNormCount() must have been called before this function,\notherwise it will always fail.\n\n@param hGrabber The handle to the grabber object.\n@param iIndex Number of the video norm to be used.\n\n@retval Nonnull The name of the specified video norm.\n@retval NULL An error occured.\n@sa IC_GetVideoNormCount\n\n*/"]
    pub fn IC_GetVideoNorm(
        hGrabber: *mut HGRABBER_t,
        iIndex: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = "\n*! Get the number of the available video formats for the current device.\nA video capture device must have been opened before this call.\n\n@param hGrabber The handle to the grabber object.\n\n@retval >= 0 Success\n@retval IC_NO_DEVICE No video capture device selected.\n@retval IC_NO_HANDLE No handle to the grabber object.\n\n@sa IC_GetVideoFormat\n*/"]
    pub fn IC_GetVideoFormatCount(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Get a string representation of the video format specified by iIndex.\niIndex must be between 0 and IC_GetVideoFormatCount().\nIC_GetVideoFormatCount() must have been called before this function,\notherwise it will always fail.\n\n@param hGrabber The handle to the grabber object.\n@param iIndex Number of the video format to be used.\n\n@retval Nonnull The name of the specified video format.\n@retval NULL An error occured.\n@sa IC_GetVideoFormatCount\n*/"]
    pub fn IC_GetVideoFormat(
        hGrabber: *mut HGRABBER_t,
        iIndex: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = "\n*! Save the state of a video capture device to a file.\n\n@param hGrabber The handle to the grabber object.\n@param szFileName Name of the file where to save to.\n\n@retval IC_SUCCESS if an image has been snapped\n@retval IC_ERROR if something went wrong.\n\n@sa IC_LoadDeviceStateFromFile\n*/"]
    pub fn IC_SaveDeviceStateToFile(
        hGrabber: *mut HGRABBER_t,
        szFileName: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Load a device settings file. On success the device is opened automatically.\n\n@param hGrabber The handle to the grabber object. If it is NULL then a new HGRABBER handle is\ncreated. This should be released by a call to IC_ReleaseGrabber when it is no longer needed.\n@param szFileName Name of the file where to save to.\n\n@return HGRABBER The handle of the grabber object, that contains the new opened video capture device.\n\n@sa IC_SaveDeviceStateToFile\n@sa IC_ReleaseGrabber\n*/"]
    pub fn IC_LoadDeviceStateFromFile(
        hGrabber: *mut HGRABBER_t,
        szFileName: *mut ::core::ffi::c_char,
    ) -> *mut HGRABBER_t;
}
extern "C" {
    #[doc = "\n*! Load a device settings file.\n\n@param hGrabber The handle to the grabber object. If it is NULL then a new HGRABBER handle is\ncreated, in case OpenDevice is true. If OpenDevice is set to false, the a device must be already\nopen in the grabber handle. The properties in the passed XML file will be apllied to\nthe opened device.\nThis should be released by a call to IC_ReleaseGrabber when it is no longer needed.\n@param szFileName Name of the file where to save to.\n@param OpenDevice If 1, the device specified in the XML file is opened. If 0, then a device must be opened in the hGrabber.\nThe properties and video format specified in the XML file will be applied to the opened device.\n\n@return IC_SUCCESS The device was successfully opened and the settings saved in the XML file were set.\n@return IC_NO_DEVICE False was passed to OpenDevice, but no device was opened in the grabber handle or the handle is NULL\n@return IC_WRONG_XML_FORMAT No device opened.\n@return IC_WRONG_INCOMPATIBLE_XML No device opened.\n@return IC_DEVICE_NOT_FOUND No device opened.\n@return IC_FILE_NOT_FOUND Passed XML file does not exist.\n@return IC_NOT_ALL_PROPERTIES_RESTORED The device was opened, but not all properties could be set as wanted.\n\n@sa IC_SaveDeviceStateToFile\n@sa IC_ReleaseGrabber\n*/"]
    pub fn IC_LoadDeviceStateFromFileEx(
        hGrabber: *mut HGRABBER_t,
        szFileName: *mut ::core::ffi::c_char,
        OpenDevice: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Save the device settings to a file specified by szFilename. When used\nwith IC Imaging Control 1.41 the device name, the input channel, the\nvideo norm and the video format are saved. When used with IC Imaging\nControl 2.0, the VCDProperties are saved as well. Returns 1 on success,\n0 otherwise.\nNotice that in IC Imaging Control 1.41 the device name includes the trailing\nnumber if there is more than one device of the same type available. This can\ncause IC_OpenDeviceBySettings() to fail if one of those devices is unplugged.\nWhen used with IC Imaging Control 2.0, this cannot happen because the device\nname is stored without the trailing number. Instead the first device that\nmatches the type specified in the settings file is opened.\n\n@deprecated Use IC_SaveDeviceStateToFile instead.\n\n*/"]
    pub fn IC_SaveDeviceSettings(
        hGrabber: *mut HGRABBER_t,
        szFilename: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Open a device by a settings file specified by szFilename. If succedeed,\n1 is returned and a device specified in the settings file is opened and\ninitialized with the settings data. If failed, 0 is returned.\n\n@deprecated Use IC_LoadDeviceStateFromFile instead.\n*/"]
    pub fn IC_OpenDeviceBySettings(
        hGrabber: *mut HGRABBER_t,
        szFilename: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Load device settings from a file specified by szFilename. A device must\nhave been opened before this function is called. A check is performed whether\nthe current device matches the device type stored in the settings file.\nIf so, the settings are loaded and set.\nReturns 1 on success, 0 otherwise.\nNotice: This function will only work with IC Imaging Control 2.0. When used\nwith IC Imaging Control 1.41, it will always return 0.\n\n@deprecated Use IC_LoadDeviceStateFromFile instead.\n*/"]
    pub fn IC_LoadDeviceSettings(
        hGrabber: *mut HGRABBER_t,
        szFilename: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Open a video capture by using its DisplayName.\n@param hGrabber The handle to the grabber object.\n@param szDisplayname Displayname of the device. Can be retrieved by a call to IC_GetDisplayName().\n\n@retval IC_SUCCESS if an image has been snapped\n@retval IC_ERROR if something went wrong.\n\n@sa IC_GetDisplayName\n*/"]
    pub fn IC_OpenDevByDisplayName(
        hGrabber: *mut HGRABBER_t,
        szDisplayname: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Get a DisplayName from a currently open device. The display name of a\ndevice can be another on different computer for the same video capture\ndevice.\n\n@param hGrabber       Handle to a grabber object\n@param szDisplayName  Memory that will take the display name. If it is NULL, the\nlength of the display name will be returned.\n@param iLen           Size in Bytes of the memory allocated by szDisplayName.\n\n\n@retval IC_SUCCESS     On success. szDisplayName contains the display name of the device.\n@retval IC_ERROR\t   iLen is less than the length of the retrieved display name.\n@retval IC_NO_HANDLE   hGrabber is not a valid handle. GetGrabber was not called.\n@retval IC_NO_DEVICE   No device opened. Open a device, before this function can be used.\n@retval >1             Length of the display name, if szDisplayName is NULL.\n\n@sa IC_OpenDevByDisplayName\n@sa IC_ReleaseGrabber\n\n*/"]
    pub fn IC_GetDisplayName(
        hGrabber: *mut HGRABBER_t,
        szDisplayname: *mut ::core::ffi::c_char,
        iLen: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Open a video capture by using its UniqueName. Use IC_GetUniqueName() to\nretrieve the unique name of a camera.\n\n@param hGrabber       Handle to a grabber object\n@param szDisplayName  Memory that will take the display name.\n\n@sa IC_GetUniqueName\n@sa IC_ReleaseGrabber\n\n*/"]
    pub fn IC_OpenDevByUniqueName(
        hGrabber: *mut HGRABBER_t,
        szDisplayname: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Get a UniqueName from a currently open device.\n\n@param hGrabber      Handle to a grabber object\n@param szUniqueName  Memory that will take the Unique name. If it is NULL, the\nlength of the Unique name will be returned.\n@param iLen          Size in Bytes of the memory allocated by szUniqueName.\n\n\n@retval IC_SUCCESS    On success. szUniqueName contains the Unique name of the device.\n@retval IC_ERROR\t  iLen is less than the length of the retrieved Unique name.\n@retval IC_NO_HANDLE  hGrabber is not a valid handle. GetGrabber was not called.\n@retval IC_NO_DEVICE  No device opened. Open a device, before this function can be used.\n@retval >1            Length of the Unique name, if szUniqueName is NULL.\n\n*/"]
    pub fn IC_GetUniqueName(
        hGrabber: *mut HGRABBER_t,
        szUniquename: *mut ::core::ffi::c_char,
        iLen: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! This returns 1, if a valid device has been opened, otherwise it is 0.\n\n@param hGrabber      Handle to a grabber object.\n\n@retval IC_ERROR There is no valid video capture device opened\n@retval IC_SUCCESS There is a valid video capture device openend.\n*/"]
    pub fn IC_IsDevValid(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Show the VCDProperty dialog.\n\n@param hGrabber      Handle to a grabber object.\n@retval IC_SUCCESS on success\n@retval IC_ERROR on error.\n@retval IC_NO_DEVICE No video capture device selected.\n@retval IC_NO_HANDLE Nullpointer.\n*/"]
    pub fn IC_ShowPropertyDialog(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Show the device selection dialog. This dialogs enables to select the\nvideo capture device, the video norm, video format, input channel and\nframe rate.\n\n@param hGrabber      Handle to a grabber object.\n\n@return The passed hGrabber object or a new created if hGrabber was NULL.\n\n@code\nHGRABBER hTheGrabber;\nhTheGrabber = IC_ShowDeviceSelectionDialog( NULL );\nif( hTheGrabber != NULL )\n{\nIC_StartLive( hTheGrabber, 1 ); // Show the live video of this grabber\nIC_ShowPropertyDialog( hTheGrabber );\t// Show the property page of this grabber\n}\n@endcode\n*/"]
    pub fn IC_ShowDeviceSelectionDialog(hGrabber: *mut HGRABBER_t) -> *mut HGRABBER_t;
}
extern "C" {
    #[doc = "\n*!\nReturn whether the current video capture device supports an external\ntrigger.\n\n@param hGrabber      Handle to a grabber object.\n@retval IC_SUCCESS An external trigger is supported\n@retval IC_ERROR No external trigger is supported.\n@retval IC_NO_DEVICE No video capture device selected.\n@retval IC_NO_HANDLE Internal Grabber does not exist.\n\n@sa IC_EnableTrigger\n*/"]
    pub fn IC_IsTriggerAvailable(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*!\tEnable or disable the external trigger.\n@param hGrabber      Handle to a grabber object.\n@param iEnable 1 = enable the trigger, 0 = disable the trigger\n\n@retval IC_SUCCESS    Trigger was enabled or disabled successfully.\n@retval IC_NOT_AVAILABLE The device does not support triggering.\n@retval IC_NO_PROPERTYSET Failed to query the property set of the device.\n@retval IC_NO_DEVICE No video capture device selected.\n\n@retval IC_NO_HANDLE Internal Grabber does not exist or hGrabber is NULL.\n\n@sa IC_IsTriggerAvailable\n*/"]
    pub fn IC_EnableTrigger(
        hGrabber: *mut HGRABBER_t,
        iEnable: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*!\tRemove or insert the  the overlay bitmap to the grabber object. If\nY16 format is used, the overlay must be removed,\n\n@param hGrabber      Handle to a grabber object.\n@param iEnable = 1 inserts overlay, 0 removes the overlay.\n*/"]
    pub fn IC_RemoveOverlay(hGrabber: *mut HGRABBER_t, iEnable: ::core::ffi::c_int);
}
extern "C" {
    #[doc = "\n*!\tEnable or disable the overlay bitmap on the live video\n@param hGrabber      Handle to a grabber object.\n@param iEnable = 1 enables the overlay, 0 disables the overlay.\n*/"]
    pub fn IC_EnableOverlay(hGrabber: *mut HGRABBER_t, iEnable: ::core::ffi::c_int);
}
extern "C" {
    #[doc = "\n*!  BeginPaint returns an HDC for GDI painting purposes (like TextOut() etc.)\nWhen the paintings are finished, the function IC_EndPaint must be called.\n\n@param hGrabber      Handle to a grabber object.\n\n@return HDC The function returns not NULL, if the HDC could be retrieved. If the HDC\ncould not be retrieved or an error has occured, the function returns 0.\n\nSample code:\n@code\nHDC hPaintDC;\nhPaintDC = IC_BeginPaint(hGrabber);\nif( hPaintDC != NULL )\n{\nTextOut( hPaintDC,10,10,\"Text\",4);\n}\nIC_EndPaint(hGrabber)\n@endcode\n\n@sa IC_EndPaint\n*/"]
    pub fn IC_BeginPaint(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_long;
}
extern "C" {
    #[doc = "\n*!  The EndPaint functions must be called, after BeginPaint has been called,\nand the painting operations have been finished.\n@param hGrabber      Handle to a grabber object.\n@sa IC_BeginPaint\n*/"]
    pub fn IC_EndPaint(hGrabber: *mut HGRABBER_t);
}
extern "C" {
    #[doc = "\n*! Display a windows messagebox.\n@param szText Message text\n@param zsTitle Title of the messagebox.\n*/"]
    pub fn IC_MsgBox(szText: *mut ::core::ffi::c_char, szTitle: *mut ::core::ffi::c_char);
}
#[doc = "\n*! Type declaration for the frame ready callback function.\n@sa IC_SetFrameReadyCallback\n@sa IC_SetCallbacks\n@retval IC_SUCCESS Callback was set successfully\n@retval IC_ERROR An error occurred, e.g. hGrabber is NULL.\n\n*/"]
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct FRAME_READY_CALLBACK(
    pub  ::core::option::Option<
        unsafe extern "C" fn(
            hGrabber: *mut HGRABBER_t,
            pData: *mut ::core::ffi::c_uchar,
            frameNumber: ::core::ffi::c_ulong,
            arg1: *mut ::core::ffi::c_void,
        ),
    >,
);
impl ::core::ops::Deref for FRAME_READY_CALLBACK {
    type Target = ::core::option::Option<
        unsafe extern "C" fn(
            hGrabber: *mut HGRABBER_t,
            pData: *mut ::core::ffi::c_uchar,
            frameNumber: ::core::ffi::c_ulong,
            arg1: *mut ::core::ffi::c_void,
        ),
    >;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::core::ops::DerefMut for FRAME_READY_CALLBACK {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
#[doc = "\n*! Type declaration for the device lost callback function.\n@sa IC_SetCallbacks\n*/"]
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct DEVICE_LOST_CALLBACK(
    pub  ::core::option::Option<
        unsafe extern "C" fn(hGrabber: *mut HGRABBER_t, arg1: *mut ::core::ffi::c_void),
    >,
);
impl ::core::ops::Deref for DEVICE_LOST_CALLBACK {
    type Target = ::core::option::Option<
        unsafe extern "C" fn(hGrabber: *mut HGRABBER_t, arg1: *mut ::core::ffi::c_void),
    >;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::core::ops::DerefMut for DEVICE_LOST_CALLBACK {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
extern "C" {
    #[doc = "\n*!\tEnable frame ready callback.\n@param hGrabber      Handle to a grabber object.\n@param cb Callback function of type FRAME_READY_CALLBACK\n@param x1_argument_in_void_userdata Pointer to some userdata.\n\n@retval IC_SUCCESS Callback was set successfully\n@retval IC_ERROR An error occurred, e.g. hGrabber is NULL.\n\n@sa FRAME_READY_CALLBACK\n\n*/"]
    pub fn IC_SetFrameReadyCallback(
        hGrabber: *mut HGRABBER_t,
        cb: FRAME_READY_CALLBACK,
        x1_argument_in_void_userdata: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\tSet callback function\n@param hGrabber      Handle to a grabber object.\n@param cb Callback function of type FRAME_READY_CALLBACK, can be NULL, if no callback is needed\n@param dlcb Callback function of type DEVICE:LOST_CALLBACK, can be NULL, if no device lost handler is needed\n@param x1_argument_in_void_userdata Pointer to some userdata.\n\n@sa FRAME_READY_CALLBACK"]
    pub fn IC_SetCallbacks(
        hGrabber: *mut HGRABBER_t,
        cb: FRAME_READY_CALLBACK,
        x1_argument_in_void_userdata: *mut ::core::ffi::c_void,
        dlCB: DEVICE_LOST_CALLBACK,
        x2_argument_in_void_userdata: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*!\tSet Continuous mode\n\nIn continuous mode, the callback is called for each frame,\nso that there is no need to use IC_SnapImage etc.\n\n@param hGrabber      Handle to a grabber object.\n@param cont\t\t\t0 : Snap continouos, 1 : do not automatically snap.\n\n@retval IC_SUCCESS Success\n@retval IC_NOT_IN_LIVEMODE The device is currently streaming, therefore setting continuous mode failed.\n@retval IC_NO_HANDLE Internal Grabber does not exist or hGrabber is NULL\n\n@remarks\nNot available in live mode.\n\n*/"]
    pub fn IC_SetContinuousMode(
        hGrabber: *mut HGRABBER_t,
        cont: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! SignalDetected\n\nDetects whether a video signal is available.\n\n@param hGrabber      Handle to a grabber object.\n\n@retval IC_SUCCESS   Signal detected\n@retval IC_ERROR  No video signal detected\n@retval IC_NO_HANDLE  Invalid grabber handle\n@retval IC_NO_DEVICE    No video capture device opened\n@retval IC_NOT_IN_LIVEMODE  No live mode, startlive was not called\n*/"]
    pub fn IC_SignalDetected(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Get trigger modes.\nSimple sample to list the video capture devices:\n\n@param hGrabber      Handle to a grabber object.\n@param szModeList\tTwodimensional array of char that will recieve the mode list.\n@param iSze\t\t\tSize of the array (first dimension)\n\n@retval 0 : No trigger modes available\n@retval >0 : Count of available trigger modes\n@retval IC_NO_HANDLE  Invalid grabber handle\n@retval IC_NO_DEVICE  No video capture device opened\n\n@code\nchar szModes[20][10];\nint iModeCount;\n\niModeCount = IC_GetTriggerModes(hGrabber, (char*)szModes,20);\nfor( int i = 0; i < min( iModeCount, 20); i++ )\n{\nprintf(\"%2d. %s\\n\",i+1,szModes[i]);\n}\n@endcode\n*/"]
    pub fn IC_GetTriggerModes(
        hGrabber: *mut HGRABBER_t,
        szModeList: *mut ::core::ffi::c_char,
        iSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*!  Set the trigger mode.\nSets the mode that has been retrieved  by a call to IC_GetTriggerModes.\n\n@param hGrabber\tHandle to a grabber object.\n@param szMode\tString containing the name of the mode.\n\n@retval IC_SUCCESS\t\tSuccess.\n@retval IC_NOT_AVAILABLE Triggermode is not supported by the current device.\n@retval IC_ERROR\t\tAn error occurred\n@retval IC_NO_HANDLE\tInvalid grabber handle\n@retval IC_NO_DEVICE    No video capture device opened\n\n*/"]
    pub fn IC_SetTriggerMode(
        hGrabber: *mut HGRABBER_t,
        szMode: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Set the trigger polarity\n\nSample:\n@code\nIC_SetTriggerPolarity(hGrabber, 0);\n@endcode\nor\n@code\nIC_SetTriggerPolarity(hGrabber, 1);\n@endcode\n@param hGrabber\tHandle to a grabber object.\n@param iPolarity\n@li 0 : Polarity on direction\n@li 1 : Polarity the other direction\n\n@retval IC SUCCESS : Polarity could be set successfully\n@retval IC_NOT_AVAILABLE Triggerpolarity is not supported by the current device.\n@retval IC_NO_HANDLE\tInvalid grabber handle\n@retval IC_NO_DEVICE    No video capture device opened\n*/"]
    pub fn IC_SetTriggerPolarity(
        hGrabber: *mut HGRABBER_t,
        iPolarity: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_GetExpRegValRange(
        hGrabber: *mut HGRABBER_t,
        lMin: *mut ::core::ffi::c_long,
        lMax: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_GetExpRegVal(
        hGrabber: *mut HGRABBER_t,
        lValue: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_SetExpRegVal(
        hGrabber: *mut HGRABBER_t,
        lValue: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_EnableExpRegValAuto(
        hGrabber: *mut HGRABBER_t,
        iOnOff: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_GetExpRegValAuto(
        hGrabber: *mut HGRABBER_t,
        iOnOff: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Functions for the absolute values interface of exposure.\n*/"]
    pub fn IC_IsExpAbsValAvailable(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_GetExpAbsValRange(
        hGrabber: *mut HGRABBER_t,
        fMin: *mut f32,
        fMax: *mut f32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_GetExpAbsVal(hGrabber: *mut HGRABBER_t, fValue: *mut f32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_SetExpAbsVal(hGrabber: *mut HGRABBER_t, fValue: f32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Gets the current value of Colorenhancement property\nSample:\n@code\nint OnOFF\nIC_GetColorEnhancement(hGrabber, &OnOFF);\n@endcode\n@param hGrabber\tHandle to a grabber object.\n@param OnOff\n@li 0 : Color enhancement is off\n@li 1 : Color enhancement is on\n\n@retval IC_SUCCESS : Success\n@retval IC_NOT:AVAILABLE : The property is not supported by the current device\n@retval IC_NO_HANDLE\tInvalid grabber handle\n@retval IC_NO_DEVICE    No video capture device opened\n*/"]
    pub fn IC_GetColorEnhancement(
        hGrabber: *mut HGRABBER_t,
        OnOff: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Sets the  value of Colorenhancement property\nSample:\n@code\nint OnOFF = 1\nIC_GetColorEnhancement(hGrabber, OnOFF);\n@endcode\n@param hGrabber\tHandle to a grabber object.\n@param OnOff\n@li 0 : Color enhancement is off\n@li 1 : Color enhancement is on\n\n@retval IC_SUCCESS : Success\n@retval IC_NOT:AVAILABLE : The property is not supported by the current device\n@retval IC_NO_HANDLE\tInvalid grabber handle\n@retval IC_NO_DEVICE    No video capture device opened\n*/"]
    pub fn IC_SetColorEnhancement(
        hGrabber: *mut HGRABBER_t,
        OnOff: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Sends a software trigger to the camera. The camera must support\nexternal trigger. The external trigger has to be enabled previously\n\n@param hGrabber\tHandle to a grabber object.\n@retval IC_SUCCESS : Success\n@retval IC_NOT:AVAILABLE : The property is not supported by the current device\n@retval IC_NO_HANDLE\tInvalid grabber handle\n@retval IC_NO_DEVICE    No video capture device opened\n\n@sa IC_EnableTrigger\n\n*/"]
    pub fn IC_SoftwareTrigger(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Sets a new frame rate.\n@param hGrabber\tHandle to a grabber object.\n@param FrameRate The new frame rate.\n@retval IC_SUCCESS : Success\n@retval IC_NOT_AVAILABLE : The property is not supported by the current device\n@retval IC_NO_HANDLE\tInvalid grabber handle\n@retval IC_NO_DEVICE    No video capture device opened\n@retval IC_NOT_IN_LIVEMODE Frame rate can not set, while live video is shown. Stop Live video first!\n*/"]
    pub fn IC_SetFrameRate(hGrabber: *mut HGRABBER_t, FrameRate: f32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Retrieves the current frame rate\n\n@param hGrabber\tHandle to a grabber object.\n@retval The current frame rate. If it is 0.0, then frame rates are not supported.\n*/"]
    pub fn IC_GetFrameRate(hGrabber: *mut HGRABBER_t) -> f32;
}
extern "C" {
    #[doc = "\n*! Retrieves available frame rates.\nThe count of available frame rates depends on the used video capture\ndevice and the currently used video format. After a video was changed,\nthe available frame rates usually are changed by the video capture device\ntoo.\n@code\nint Index = 0;\nfloat fps = 0.0f;\n\nwhile( IC_GetAvailableFrameRates(hGrabber, Index, &fps ) == IC_SUCCESS )\n{\nprintf(\"Frame rate %d : %f fps\\n\", Index, fps);\nIndex++;\n}\n@endcode\n\n@param hGrabber\tHandle to a grabber object.\n@param Index Index of the frame rates, starting at 0\n@param fps Pointer to a float variable, that will receive the frame rate of the passed index.\n@retval IC_SUCCESS, if the frame rate at Index exists, otherwise IC_ERROR,\n*/"]
    pub fn IC_GetAvailableFrameRates(
        hGrabber: *mut HGRABBER_t,
        Index: ::core::ffi::c_int,
        fps: *mut f32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn IC_SetWhiteBalanceAuto(
        hGrabber: *mut HGRABBER_t,
        iOnOff: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Sets the value for white balance red.\n\n@param hGrabber\tHandle to a grabber object.\n@param Value\tValue of the red white balance to be set\n@retval IC_SUCCESS\t\t\t: Success\n@retval IC_NO_HANDLE\t\t: Invalid grabber handle\n@retval IC_NO_DEVICE\t\t: No video capture device opened\n@retval IC_NOT_AVAILABLE\t: The property is not supported by the current device\n\n*/"]
    pub fn IC_SetWhiteBalanceRed(
        hGrabber: *mut HGRABBER_t,
        Value: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Sets the value for white balance green.\n\n@param hGrabber\tHandle to a grabber object.\n@param Value\tValue of the green white balance to be set\n@retval IC_SUCCESS\t\t\t: Success\n@retval IC_NO_HANDLE\t\t: Invalid grabber handle\n@retval IC_NO_DEVICE\t\t: No video capture device opened\n@retval IC_NOT_AVAILABLE\t: The property is not supported by the current device\n\n*/"]
    pub fn IC_SetWhiteBalanceGreen(
        hGrabber: *mut HGRABBER_t,
        Value: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Sets the value for white balance blue.\n\n@param hGrabber\tHandle to a grabber object.\n@param Value\tValue of the blue white balance to be set\n@retval IC_SUCCESS\t\t\t: Success\n@retval IC_NO_HANDLE\t\t: Invalid grabber handle\n@retval IC_NO_DEVICE\t\t: No video capture device opened\n@retval IC_NOT_AVAILABLE\t: The property is not supported by the current device\n\n*/"]
    pub fn IC_SetWhiteBalanceBlue(
        hGrabber: *mut HGRABBER_t,
        Value: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Performs the one push  for Focus\n\n@param hGrabber\tHandle to a grabber object.\n@param Value\tValue of the blue white balance to be set\n@retval IC_SUCCESS\t\t\t: Success\n@retval IC_NO_HANDLE\t\t: Invalid grabber handle\n@retval IC_NO_DEVICE\t\t: No video capture device opened\n@retval IC_NOT_AVAILABLE\t: The property is not supported by the current device\n\n*/"]
    pub fn IC_FocusOnePush(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Show the internal property page of the camera\n*/"]
    pub fn IC_ShowInternalPropertyPage(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Resets all properties to their default values. If a property has\nautomation, the automatic will be enabled.\nIf the device supports external trigger, the external trigger will\nbe disabled.\n\n@param hGrabber\tHandle to a grabber object.\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n\n*/"]
    pub fn IC_ResetProperties(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Resets the driver. Do not use, for internl purposes only.\n\n@param hGrabber\tHandle to a grabber object.\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n*/"]
    pub fn IC_ResetUSBCam(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! This function queries the internal property set (KsPropertySet) of the driver.\nIt allows an application to access all properties of a video capture devices\nusing the enums and GUIDs from the header files fwcam1394propguid.h and\nfwcam1394props.h.\n\n@param hGrabber\tHandle to a grabber object.\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n@retval IC_ERROR\t\t\tThe property could not have been retrieved\n\n*/"]
    pub fn IC_QueryPropertySet(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Enables or disables the default window size lock of the video window.\n\n@param hGrabber\tHandle to a grabber object.\n@param Default\t0 = disable, custome size can be set, 1 = enable, the standard size, which is video format, is used.\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_ERROR\t\t\tSetting of the values failed\n@retval IC_NO_PROPERTYSET\tThe property set was not retrieved or is not available.\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n\n*/"]
    pub fn IC_SetDefaultWindowPosition(
        hGrabber: *mut HGRABBER_t,
        Default: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! This function Sets the position and size of the video window.\n\n@param hGrabber\tHandle to a grabber object.\n@param PosX  Specifies the x-coordinate of the upper left hand corner of the video window. It defaults to 0.\n@param PosY  Specifies the y-coordinate of the upper left hand corner of the video window. It defaults to 0.\n@param width  Specifies the width of the video window.\n@param height  Specifies the height of the video window.\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_ERROR\t\t\tSetting of the values failed\n@retval IC_DEFAULT_WINDOW_SIZE_SET\tThe property set was not retrieved or is not available.\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n\n*/"]
    pub fn IC_SetWindowPosition(
        hGrabber: *mut HGRABBER_t,
        PosX: ::core::ffi::c_int,
        PosY: ::core::ffi::c_int,
        Width: ::core::ffi::c_int,
        Height: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Enumerate the available properties of a video capture device.\n\n@param hGrabber\tHandle to a grabber object.\n@param cb Callback functions called by the enum function.\n@param data User data\n\n@retval IC_SUCCESS No error otherwise an error occured, e.g. no device selected.\n\n*/"]
    pub fn IC_enumProperties(
        hGrabber: *mut HGRABBER_t,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_char,
                arg2: *mut ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Enumerate the available elements of a video capture device and a property.\n\n@param hGrabber\tHandle to a grabber object.\n@param Property Name of the property\n@param cb Callback functions called by the enum function.\n@param data User data\n\n@retval IC_SUCCESS No error otherwise an error occured, e.g. no device selected.\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE The passed property in Property is not avaialble.\n*/"]
    pub fn IC_enumPropertyElements(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_char,
                arg2: *mut ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Enumerate the available interfaces of of a video capture device, property and element.\n\nThe string passed to the callback function can contain\n- Range\n- Switch\n- Button\n- Mapstrings\n- AbsoluteValues\n- Unknown\n\n@param hGrabber\tHandle to a grabber object.\n@param Property Name of the property\n@param Property Name of the elemt\n@param cb Callback functions called by the enum function.\n@param data User data\n\n@retval IC_SUCCESS No error otherwise an error occured, e.g. no device selected.\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE The passed property in Property is not avaialble.\n*/"]
    pub fn IC_enumPropertyElementInterfaces(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        Element: *mut ::core::ffi::c_char,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_char,
                arg2: *mut ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Check, whether a property is available..  For a list of properties and elements\nuse the VCDPropertyInspector of IC Imaging Control.\n\n@param hGrabber\tHandle to a grabber object.\n@param Property  The name of the property, e.g. Gain, Exposure\n@param Element  The type of the interface, e.g. Value, Auto. If NULL, it is not checked.\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n@retval IC_PROPERTY_ELEMENT_NOT_AVAILABLE\t\tA requested element of a given property item is not available\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE\t\trequested element has not the interface, which is needed.\n\nSimple call:\n@code\nif( IC_IsPropertyAvailable( hGrabber, \"Brightness\",NULL) == IC_SUCCESS )\n{\nprintf(\"Brightness is supported\\n\");\n}\nelse\n{\nprintf(\"Brightness is not supported\\n\");\n}\n@endcode\n\nComplex call for a special element:\n@code\nif( IC_IsPropertyAvailable( hGrabber, \"Trigger\",\"Software Trigger\") == IC_SUCCESS )\n{\nprintf(\"Software trigger is supported\\n\");\n}\nelse\n{\nprintf(\"Software trigger is not supported\\n\");\n}\n@endcode\n*/"]
    pub fn IC_IsPropertyAvailable(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        Element: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! This returns the range of a property.  For a list of properties and elements\nuse the VCDPropertyInspector of IC Imaging Control.\n\n@param hGrabber\tHandle to a grabber object.\n@param Property  The name of the property, e.g. Gain, Exposure\n@param Element  The type of the interface, e.g. Value, Auto. If NULL, it is \"Value\".\n@param Min  Receives the min value of the property\n@param Max  Receives the max value of the property\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE\t\tA requested property item is not available\n@retval IC_PROPERTY_ELEMENT_NOT_AVAILABLE\t\tA requested element of a given property item is not available\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE\t\trequested element has not the interface, which is needed.\n\n@code\nHGRABBER hGrabber; // The handle of the grabber object.\n\nint Min;\nint Max;\nint Result = IC_ERROR;\nHGRABBER hGrabber;\n\nif( IC_InitLibrary(0) )\n{\nhGrabber = IC_CreateGrabber();\nIC_OpenVideoCaptureDevice(hGrabber, \"DFx 31BG03.H\");\n\nif( hGrabber )\n{\nResult = IC_GetPropertyValueRange(hGrabber,\"Exposure\",\"Auto Reference\", &Min, &Max );\n\nif( Result == IC_SUCCESS )\nprintf(\"Expsure Auto Reference Min %d, Max %d\\n\", Min, Max);\n\nResult = IC_GetPropertyValueRange(hGrabber,\"Exposure\",NULL, &Min, &Max );\n\nif( Result == IC_SUCCESS )\nprintf(\"Exposure Value Min %d, Max %d\\n\", Min, Max);\n}\nIC_ReleaseGrabber( hGrabber );\n@endcode\n\n\n*/"]
    pub fn IC_GetPropertyValueRange(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        Element: *mut ::core::ffi::c_char,
        Min: *mut ::core::ffi::c_int,
        Max: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! This returns the current value of a property. For a list of properties and elements\nuse the VCDPropertyInspector of IC Imaging Control.\n\n@param hGrabber\tHandle to a grabber object.\n@param Property  The name of the property, e.g. Gain, Exposure\n@param Element  The type of the interface, e.g. Value, Auto. If NULL, it is \"Value\".\n@param Value  Receives the value of the property\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE\t\tA requested property item is not available\n@retval IC_PROPERTY_ELEMENT_NOT_AVAILABLE\t\tA requested element of a given property item is not available\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE\t\trequested element has not the interface, which is needed.\n*/"]
    pub fn IC_GetPropertyValue(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        Element: *mut ::core::ffi::c_char,
        Value: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! This sets a new value of a property.  For a list of properties and elements\nuse the VCDPropertyInspector of IC Imaging Control.\n\n@param hGrabber\tHandle to a grabber object.\n@param Property  The name of the property, e.g. Gain, Exposure\n@param Element  The type of the interface, e.g. Value, Auto. If NULL, it is \"Value\".\n@param Value  Receives the value of the property\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE\t\tA requested property item is not available\n@retval IC_PROPERTY_ELEMENT_NOT_AVAILABLE\t\tA requested element of a given property item is not available\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE\t\trequested element has not the interface, which is needed.\n*/"]
    pub fn IC_SetPropertyValue(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        Element: *mut ::core::ffi::c_char,
        Value: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! This returns the range of an absolute value property. Usually it is used for exposure.\na list of properties and elements use the VCDPropertyInspector of IC Imaging Control.\n\n@param hGrabber\tHandle to a grabber object.\n@param Property  The name of the property, e.g. Gain, Exposure\n@param Element  The type of the interface, e.g. Value, Auto. If NULL, it is \"Value\".\n@param Min  Receives the min value of the property\n@param Max  Receives the max value of the property\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE\t\tA requested property item is not available\n@retval IC_PROPERTY_ELEMENT_NOT_AVAILABLE\t\tA requested element of a given property item is not available\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE\t\trequested element has not the interface, which is needed.\n*/"]
    pub fn IC_GetPropertyAbsoluteValueRange(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        Element: *mut ::core::ffi::c_char,
        Min: *mut f32,
        Max: *mut f32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! This returns the current value of an absolute value property.\nUsually it is used for exposure. For a list of properties and elements\nuse the VCDPropertyInspector of IC Imaging Control.\n\n@param hGrabber\tHandle to a grabber object.\n@param Property  The name of the property, e.g. Gain, Exposure\n@param Element  The type of the interface, e.g. Value, Auto. If NULL, it is \"Value\".\n@param Value  Receives the value of the property\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE\t\tA requested property item is not available\n@retval IC_PROPERTY_ELEMENT_NOT_AVAILABLE\t\tA requested element of a given property item is not available\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE\t\trequested element has not the interface, which is needed.\n*/"]
    pub fn IC_GetPropertyAbsoluteValue(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        Element: *mut ::core::ffi::c_char,
        Value: *mut f32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! This sets a new value of an absolute value property. Usually it is used for exposure.\na list of properties and elements\nuse the VCDPropertyInspector of IC Imaging Control.\n\n@param hGrabber\tHandle to a grabber object.\n@param Property  The name of the property, e.g. Gain, Exposure\n@param Element  The type of the interface, e.g. Value, Auto. If NULL, it is \"Value\".\n@param Value  Receives the value of the property\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE\t\tA requested property item is not available\n@retval IC_PROPERTY_ELEMENT_NOT_AVAILABLE\t\tA requested element of a given property item is not available\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE\t\trequested element has not the interface, which is needed.\n*/"]
    pub fn IC_SetPropertyAbsoluteValue(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        Element: *mut ::core::ffi::c_char,
        Value: f32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! This returns the current value of a switch property. Switch properties\nare usually used for enabling and disabling of automatics.\nFor a list of properties and elements\nuse the VCDPropertyInspector of IC Imaging Control.\n\n@param hGrabber\tHandle to a grabber object.\n@param Property  The name of the property, e.g. Gain, Exposure\n@param Element  The type of the interface, e.g. Value, Auto. If NULL, it is \"Auto\".\n@param On  Receives the value of the property\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE\t\tA requested property item is not available\n@retval IC_PROPERTY_ELEMENT_NOT_AVAILABLE\t\tA requested element of a given property item is not available\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE\t\trequested element has not the interface, which is needed.\n*/"]
    pub fn IC_GetPropertySwitch(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        Element: *mut ::core::ffi::c_char,
        On: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! This sets the  value of a switch property. Switch properties\nare usually used for enabling and disabling of automatics.\nFor a list of properties and elements\nuse the VCDPropertyInspector of IC Imaging Control.\n\n@param hGrabber\tHandle to a grabber object.\n@param Property  The name of the property, e.g. Gain, Exposure\n@param Element  The type of the interface, e.g. Value, Auto. If NULL, it is \"Auto\".\n@param On  Receives the value of the property\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE\t\tA requested property item is not available\n@retval IC_PROPERTY_ELEMENT_NOT_AVAILABLE\t\tA requested element of a given property item is not available\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE\t\trequested element has not the interface, which is needed.\n*/"]
    pub fn IC_SetPropertySwitch(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        Element: *mut ::core::ffi::c_char,
        On: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! This executes the on push on a property. These properties are used\nfor white balance one push or for software trigger.\nFor a list of properties and elements\nuse the VCDPropertyInspector of IC Imaging Control.\n\n@param hGrabber\tHandle to a grabber object.\n@param Property  The name of the property, e.g. \"Trigger\"\n@param Element  The type of the interface, e.g. \"Software Trigger\"\n@param On  Receives the value of the property\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE\t\tA requested property item is not available\n@retval IC_PROPERTY_ELEMENT_NOT_AVAILABLE\t\tA requested element of a given property item is not available\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE\t\trequested element has not the interface, which is needed.\n*/"]
    pub fn IC_PropertyOnePush(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        Element: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*!\n\n@param hGrabber\tHandle to a grabber object.\n@param Property  The name of the property, e.g. \"Strobe\"\n@param Element  The type of the interface, e.g. \"Mode\"\n@param StringCount  Receives the count of strings, that is modes, availble\n@param Strings pointer to an array of char*, that will contain the mode strings. The array size should be StringCount * 20. Parameter can be null in order to query the number of strings\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE\t\tA requested property item is not available\n@retval IC_PROPERTY_ELEMENT_NOT_AVAILABLE\t\tA requested element of a given property item is not available\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE\t\trequested element has not the interface, which is needed.\n*/"]
    pub fn IC_GetPropertyMapStrings(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        Element: *mut ::core::ffi::c_char,
        StringCount: *mut ::core::ffi::c_int,
        Strings: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Return the current set string of a mapstring interface\n\n@param hGrabber\tHandle to a grabber object.\n@param Property  The name of the property, e.g. \"Strobe\"\n@param Element  The type of the interface, e.g. \"Mode\"\n@param String\t pointer to a char*. Size should be atleast 50. There is no check! This contains the result.\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE\t\tA requested property item is not available\n@retval IC_PROPERTY_ELEMENT_NOT_AVAILABLE\t\tA requested element of a given property item is not available\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE\t\trequested element has not the interface, which is needed.\n*/"]
    pub fn IC_GetPropertyMapString(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        Element: *mut ::core::ffi::c_char,
        String: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Set the string of a mapstring interface\n\n@param hGrabber\tHandle to a grabber object.\n@param Property  The name of the property, e.g. \"Strobe\"\n@param Element  The type of the interface, e.g. \"Mode\"\n@param String\t pointer to a char*. Size should be atleast 50. There is no check! This contains the result.\n\n@retval IC_SUCCESS\t\t\tSuccess\n@retval IC_NO_HANDLE\t\tInvalid grabber handle\n@retval IC_NO_DEVICE\t\tNo video capture device opened\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE\t\tA requested property item is not available\n@retval IC_PROPERTY_ELEMENT_NOT_AVAILABLE\t\tA requested element of a given property item is not available\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE\t\trequested element has not the interface, which is needed.\n*/"]
    pub fn IC_SetPropertyMapString(
        hGrabber: *mut HGRABBER_t,
        Property: *mut ::core::ffi::c_char,
        Element: *mut ::core::ffi::c_char,
        String: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Query number of avaialable frame filters\n\n@retval The count of found frame filters.\n*/"]
    pub fn IC_GetAvailableFrameFilterCount() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Query a list of framefilters\n\n@param szFilterList A two dimensional char array that recieves the list of found frame filters\n@param iSize The number of entries in the above list.\n@code\nchar szFilterList[80][40];\nint iCount;\niCount = IC_GetAvailableFrameFilterCount();\n\niFormatCount = IC_GetAvailableFrameFilters(szFormatList,iCount );\n\nfor( i = 0; i < iCount; i++ )\n{\nprintf(\"%2d. %s\\n\",i+1,szFormatList[i]);\n}\n@endcode\n*/"]
    pub fn IC_GetAvailableFrameFilters(
        szFilterList: *mut *mut ::core::ffi::c_char,
        iSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Create a frame filter\n@param szFilterName Name of the filter to create\n@param FilterHandle Address of a pointer, that will receive the handle of the created filter\n\n@retval IC_SUCCESS\tSuccess\n@retval IC_ERROR\tIf the filter creation failed.\n\n@sa IC_DeleteFrameFilter\n*/"]
    pub fn IC_CreateFrameFilter(
        szFilterName: *mut ::core::ffi::c_char,
        FilterHandle: *mut HFRAMEFILTER_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Add the frame filter to the device's filter list. It is possible to add several\nframe filter to a grabber, so a filter chain for image processing can be created.\nA frame filter is removed by a call to IC_RemoveFrameFilter\n\n@param hGrabber\tHandle to a grabber object.\n@param FilterHandle\tHandle to a frame filter object.\n\n@retval IC_SUCCESS\tSuccess\n@retval IC_ERROR Either hGrabber or FilterHandle was NULL\n\n@sa IC_RemoveFrameFilterFromDevice\n@sa IC_CreateFrameFilter\n*/"]
    pub fn IC_AddFrameFilterToDevice(
        hGrabber: *mut HGRABBER_t,
        FilterHandle: HFRAMEFILTER_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Removes a previously added frame filter from the frame filter list\n\n@param hGrabber\tHandle to a grabber object, that uses the passed frame filter.\n@param FilterHandle\tHandle to a frame filter object, to be removed\n\n@sa IC_AddFrameFilterToDevice\n@sa IC_CreateFrameFilter\n\n*/"]
    pub fn IC_RemoveFrameFilterFromDevice(hGrabber: *mut HGRABBER_t, FilterHandle: HFRAMEFILTER_t);
}
extern "C" {
    #[doc = "\n*! Deletes a previously created frame filter. Make sure, the frame filter to be deleted\nis not in use anymore, otherwise a null pointer access violation will occur.\n\n@param FilterHandle\tHandle to a frame filter object.\n*/"]
    pub fn IC_DeleteFrameFilter(FilterHandle: HFRAMEFILTER_t);
}
extern "C" {
    pub fn IC_FrameFilterShowDialog(FilterHandle: HFRAMEFILTER_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Query a parameter value of a frame filter\n@param FilterHandle\tHandle to a frame filter object.\n@param ParameterName Name of the parameter whose value is to be queried\n@param Data pointer to the data, that receives the value. Memory must be allocated before.\n\n@retval IC_SUCCESS\tSuccess\n@retval IC_ERROR  Maybe the parameter name does not exist.\n\n*/"]
    pub fn IC_FrameFilterGetParameter(
        FilterHandle: HFRAMEFILTER_t,
        ParameterName: *mut ::core::ffi::c_char,
        Data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Set an int parameter value of a frame filter\n@param FilterHandle\tHandle to a frame filter object.\n@param ParameterName Name of the parameter whose value is to be set\n@param Data The data, that contains the value.\n\n@retval IC_SUCCESS\tSuccess\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE the parameter givven by ParameterName does not exist\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE The data type, e.g. int does not match to the parameter type, e.g. float\n@retval IC_ERROR  Unknown error"]
    pub fn IC_FrameFilterSetParameterInt(
        FilterHandle: HFRAMEFILTER_t,
        ParameterName: *mut ::core::ffi::c_char,
        Data: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Set a float parameter value of a frame filter\n@param FilterHandle\tHandle to a frame filter object.\n@param ParameterName Name of the parameter whose value is to be set\n@param Data The data, that contains the value.\n\n@retval IC_SUCCESS\tSuccess\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE the parameter givven by ParameterName does not exist\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE The data type, e.g. int does not match to the parameter type, e.g. float\n@retval IC_ERROR  Unknown error"]
    pub fn IC_FrameFilterSetParameterFloat(
        FilterHandle: HFRAMEFILTER_t,
        ParameterName: *mut ::core::ffi::c_char,
        Data: f32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Set a boolean parameter value of a frame filter. boolean means int here.\n@param FilterHandle\tHandle to a frame filter object.\n@param ParameterName Name of the parameter whose value is to be set\n@param Data The data, that contains the value.\n\n@retval IC_SUCCESS\tSuccess\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE the parameter givven by ParameterName does not exist\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE The data type, e.g. int does not match to the parameter type, e.g. float\n@retval IC_ERROR  Unknown error"]
    pub fn IC_FrameFilterSetParameterBoolean(
        FilterHandle: HFRAMEFILTER_t,
        ParameterName: *mut ::core::ffi::c_char,
        Data: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Set a string parameter value of a frame filter\n@param FilterHandle\tHandle to a frame filter object.\n@param ParameterName Name of the parameter whose value is to be set\n@param Data The data, that contains the value.\n\n@retval IC_SUCCESS\tSuccess\n@retval IC_PROPERTY_ITEM_NOT_AVAILABLE the parameter givven by ParameterName does not exist\n@retval IC_PROPERTY_ELEMENT_WRONG_INTERFACE The data type, e.g. int does not match to the parameter type, e.g. float\n@retval IC_ERROR  Unknown error"]
    pub fn IC_FrameFilterSetParameterString(
        FilterHandle: HFRAMEFILTER_t,
        ParameterName: *mut ::core::ffi::c_char,
        Data: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Remove all frame filters from the Grabber's device path\n@param hGrabber\tHandle to a grabber object.\n\n*/"]
    pub fn IC_FrameFilterDeviceClear(hGrabber: *mut HGRABBER_t) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct CODECHANDLE_t__ {
    #[doc = "<Internal structure of the grabber object handle."]
    pub unused: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CODECHANDLE_t__"][::core::mem::size_of::<CODECHANDLE_t__>() - 4usize];
    ["Alignment of CODECHANDLE_t__"][::core::mem::align_of::<CODECHANDLE_t__>() - 4usize];
    ["Offset of field: CODECHANDLE_t__::unused"]
        [::core::mem::offset_of!(CODECHANDLE_t__, unused) - 0usize];
};
#[repr(transparent)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct CODECHANDLE_t(pub CODECHANDLE_t__);
impl ::core::ops::Deref for CODECHANDLE_t {
    type Target = CODECHANDLE_t__;
    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::core::ops::DerefMut for CODECHANDLE_t {
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
extern "C" {
    #[doc = "\n*! Enumerate all installed codecs. It calls the callback function passed by\nthe cb parameter. It ends, if cb returns 0 or all codecs have been enumerated.\n\n@param cb pallack function of type ENUMCODECCB\n@param data Pointer to user data\n*/"]
    pub fn IC_enumCodecs(
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_char,
                arg2: *mut ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
        data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "\n*! Creates the codec by the passed name\n\n@param Name Name of the codec to be created\n@retval NULL on error, otherwise the created HCODEC\n*/"]
    pub fn IC_Codec_Create(Name: *mut ::core::ffi::c_char) -> *mut CODECHANDLE_t;
}
extern "C" {
    pub fn IC_Codec_Release(Codec: *mut CODECHANDLE_t);
}
extern "C" {
    #[doc = "\n*! Queries a name of a codec passed by _Codec\n\n@param _Codec Handle to the codec\n@param l Size in bytes of the memory allocated for name\n@param name String that will receive the name of the codec terminated by a \\0\n\n@retval IC_SUCCESS on success\n@retval IC_NO_HANDLE if _Codec or Name is NULL\n*/"]
    pub fn IC_Codec_getName(
        Codec: *mut CODECHANDLE_t,
        l: ::core::ffi::c_int,
        Name: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Return whether a codec passed by _Codec has a property dialog\n\n@param _Codec Handle to the codec\n\n@retval IC_SUCCESS The codec has a dialog\n@retval IC_ERROR The codec has no dialog\n@retval IC_NO_HANDLE  _Codec is NULL\n*/"]
    pub fn IC_Codec_hasDialog(Codec: *mut CODECHANDLE_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Shows the property dialog of a codec passed by _Codec\n\n@param name String that will receive the name of the codec terminated by a \\0\n\n@retval IC_SUCCESS on success\n@retval IC_ERROR On error, e.g. something went wrong with the codec's dialog.\n@retval IC_NO_HANDLE if _Codec or Name is NULL\n*/"]
    pub fn IC_Codec_showDialog(Codec: *mut CODECHANDLE_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Assigns the selected Codec to the Grabber. AVI Capture is prepared. Image\ncapture does not work anymore.\n\nAfter doing so, a call to IC_Startlive() starts AVI Capture and IC_Stoplive stopps it,\n\n@param hlGrabber Handle to a grabber with a valid device\n@param Codec Handle to the selected codec.\n\n@retval IC_SUCCESS on success\n*/"]
    pub fn IC_SetCodec(hlGrabber: *mut HGRABBER_t, Codec: *mut CODECHANDLE_t)
        -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Set the file name for the AVI file\n\nAfter doing so, a call to IC_Startlive() starts AVI Capture and IC_Stoplive stopps it,\n\n@param hlGrabber Handle to a grabber with a valid device\n@param FileName Filename\n\n@retval IC_SUCCESS on success\n@retval IC_NO_HANDLE if the grabber is invalid\n\n*/"]
    pub fn IC_SetAVIFileName(
        hlGrabber: *mut HGRABBER_t,
        FileName: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "\n*! Pauses or continues AVI Capture. This allows, to start the stream and see the live video\nbut images are not saved into the AVI file.\n\n\n@param hlGrabber Handle to a grabber with a valid device\n@param pause  1 = Pause, nothing saved, 0 = save images!\n\n@retval IC_SUCCESS on success\n@retval IC_NO_HANDLE if the grabber is invalid\n*/"]
    pub fn IC_enableAVICapturePause(
        hlGrabber: *mut HGRABBER_t,
        Pause: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
